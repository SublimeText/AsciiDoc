%YAML 1.2
---
# https://www.sublimetext.com/docs/syntax.html
# https://asciidoc.org
name: AsciiDoc
scope: text.html.asciidoc
version: 2

file_extensions:
  - adoc
  - asciidoc
  - asc

contexts:

  main:
    - include: blocks
    # - include: old-main

###[ BLOCKS ]##################################################################

  blocks:
    - include: comments
    - match: ^\+$
      scope: punctuation.separator.continuation.line.asciidoc
    - include: includes
    - include: conditionals
    - include: document-attribute-declarations
    - include: breaks
    - include: section-titles
    - include: lists
    - include: description-lists
    - include: passthrough-blocks
    - include: verbatims-and-source-blocks
    - include: tables
    - include: admonitions
    - include: sidebars
    - include: example-blocks
    - include: verses
    - include: blockquotes
    - include: open-blocks
    - include: block-images
    - include: audios-and-videos
    - include: attribute-lists

    # TODO: Figure out where this belongs
    - match: ^(\.)
      scope: punctuation.section.block.asciidoc
      push:
        - meta_content_scope: markup.bold.asciidoc
        - include: eol-pop

    # Paragraphs at the end
    - include: literal-paragraphs
    - include: paragraphs

  indented-blocks:
    - include: comments
    - match: ^\+$
      scope: punctuation.separator.continuation.line.asciidoc
    - include: includes
    - include: conditionals
    - include: document-attribute-declarations
    - include: breaks
    - include: section-titles
    - include: lists
    - include: description-lists
    - include: passthrough-blocks
    - include: verbatims-and-source-blocks
    - include: tables
    - include: admonitions
    - include: sidebars
    - include: example-blocks
    - include: verses
    - include: blockquotes
    - include: open-blocks
    - include: block-images
    - include: audios-and-videos
    - include: attribute-lists

    # TODO: Figure out where this belongs
    - match: ^(\.)
      scope: punctuation.section.block.asciidoc
      push:
        - meta_content_scope: markup.bold.asciidoc
        - include: eol-pop

    # Paragraphs at the end
    - include: paragraphs

  inlines:
    - match: (?!^)(\+)\s*$
      captures:
        1: constant.character.break.asciidoc
    - match: \\.
      scope: constant.character.escape.asciidoc
    - include: document-attributes
    - include: inline-images
    - include: bibliography-references
    - include: cross-references
    - include: attribute-lists
    - include: passthrough-inlines
    - include: links
    - include: text-formatting
    - include: footnotes
    - include: keyboard-macro
    - include: button-menu-macro
    - include: substitutions

###[ DOCUMENT ATTRIBUTES ]#####################################################

  document-attribute-declarations:
    - match: ((:){{identifier}}(:))[ ]*
      captures:
        1: variable.other.readwrite.asciidoc
        2: punctuation.definition.variable.begin.asciidoc
        3: punctuation.definition.variable.end.asciidoc
      push: maybe-document-attribute-assignment

  maybe-document-attribute-assignment:
    - meta_content_scope: string.unquoted.asciidoc
    - match: \\\n?
      scope: punctuation.separator.continuation.line.asciidoc
    - include: eol-pop
    - include: inlines

  document-attributes:
    - match: ({)empty(})
      scope: constant.language.null.asciidoc
      captures:
        1: punctuation.definition.variable.begin.asciidoc
        2: punctuation.definition.variable.end.asciidoc
    - match: ({){{identifier}}(})
      scope: variable.other.readwrite.asciidoc
      captures:
        1: punctuation.definition.variable.begin.asciidoc
        2: punctuation.definition.variable.end.asciidoc

###[ ELEMENT ATTRIBUTES ]######################################################

  attribute-lists:
    - match: \[(?!\[)
      scope: punctuation.section.group.parameters.begin.asciidoc
      push: attribute-list-body

  attribute-list-body:
    - meta_scope: meta.brackets.asciidoc
    - match: \]
      scope: punctuation.section.group.parameters.end.asciidoc
      pop: 1
    - include: attribute-list-contents

  attribute-list-contents:
    - match: \G{{admonition}}
      scope: support.type.admonition.asciidoc
    - match: \G{{block_type}}
      scope: support.type.block.asciidoc
    - include: comma-separator
    - include: named-attributes
    - include: attribute-anchors
    - include: attribute-roles
    - include: attribute-options
    - include: document-attributes
    - include: autolinks

  named-attributes:
    - match: \b([\w-]+)(=)
      captures:
        1: meta.mapping.key.asciidoc entity.other.attribute-name.asciidoc
        2: punctuation.separator.key-value.asciidoc
      push: named-attribute-value

  named-attribute-value:
    - meta_scope: meta.attribute-with-value.asciidoc
    - meta_content_scope: meta.mapping.value.asciidoc
    - match: (?=[,\]#.%])
      pop: 1
    - include: autolinks
    - match: \G"
      scope: punctuation.definition.string.begin.asciidoc
      push:
        - meta_scope: meta.string.asciidoc string.quoted.double.asciidoc
        - match: '"'
          scope: punctuation.definition.string.end.asciidoc
          pop: 1

  attribute-anchors:
    - match: (#){{identifier}}
      scope: entity.name.reference.link.asciidoc
      captures:
        1: punctuation.definition.asciidoc

  attribute-roles:
    - match: (\.){{identifier}}
      scope: storage.modifier.role.asciidoc
      captures:
        1: punctuation.definition.asciidoc

  attribute-options:
    - match: (%){{identifier}}
      scope: keyword.other.option.asciidoc
      captures:
        1: punctuation.definition.keyword.asciidoc

  comma-separator:
    - match: ','
      scope: punctuation.separator.sequence.asciidoc

###[ DOCUMENT HEADER ]#########################################################

  # TODO: Add an author block after the document header?

###[ DOCUMENT TYPE ]###########################################################

  # Nothing to do here

###[ SECTIONS ]################################################################

  # https://docs.asciidoctor.org/asciidoc/latest/sections/titles-and-levels/
  section-titles:
    - match: (=|#)[ ]
      captures:
        1: punctuation.definition.heading.begin.asciidoc
      push: section-title-0-body
    - match: (==|##)[ ]
      captures:
        1: punctuation.definition.heading.begin.asciidoc
      push: section-title-1-body
    - match: (===|###)[ ]
      captures:
        1: punctuation.definition.heading.begin.asciidoc
      push: section-title-2-body
    - match: (={4}|#{4})[ ]
      captures:
        1: punctuation.definition.heading.begin.asciidoc
      push: section-title-3-body
    - match: (={5}|#{5})[ ]
      captures:
        1: punctuation.definition.heading.begin.asciidoc
      push: section-title-3-body
    - match: (={6}|#{6})[ ]
      captures:
        1: punctuation.definition.heading.begin.asciidoc
      push: section-title-3-body

  section-title-0-body:
    - meta_scope: markup.heading.0.asciidoc
    - meta_content_scope: entity.name.section.asciidoc
    - include: eol-pop
    - include: inlines

  section-title-1-body:
    - meta_scope: markup.heading.1.asciidoc
    - meta_content_scope: entity.name.section.asciidoc
    - include: eol-pop
    - include: inlines

  section-title-2-body:
    - meta_scope: markup.heading.2.asciidoc
    - meta_content_scope: entity.name.section.asciidoc
    - include: eol-pop
    - include: inlines

  section-title-3-body:
    - meta_scope: markup.heading.3.asciidoc
    - meta_content_scope: entity.name.section.asciidoc
    - include: eol-pop
    - include: inlines

  section-title-4-body:
    - meta_scope: markup.heading.4.asciidoc
    - meta_content_scope: entity.name.section.asciidoc
    - include: eol-pop
    - include: inlines

  section-title-5-body:
    - meta_scope: markup.heading.5.asciidoc
    - meta_content_scope: entity.name.section.asciidoc
    - include: eol-pop
    - include: inlines

  bibliography-references:
    - match: \[{3}
      scope: punctuation.definition.reference.begin.asciidoc
      push: bibliography-reference-body

  bibliography-reference-body:
    - meta_content_scope: meta.link.reference.metadata.asciidoc entity.name.reference.link.asciidoc
    - match: \]{3}
      scope: punctuation.definition.reference.end.asciidoc
      pop: 1
    - match: ','
      scope: punctuation.separator.sequence.asciidoc
      set: bibliography-reference-attributes

  bibliography-reference-attributes:
    - meta_content_scope: meta.link.reference.metadata.asciidoc
    - match: \]{3}
      scope: punctuation.definition.reference.end.asciidoc
      pop: 1
    - include: attribute-list-contents

###[ PARAGRAPHS ]##############################################################

  paragraphs:
    - match: ^(?=\S)
      push: paragraph-body

  paragraph-body:
    - meta_scope: meta.paragraph.asciidoc
    - include: paragraph-body-pops
    - include: comments-inline
    - include: inlines

  literal-paragraphs:
    - match: ^\s+(?=\S)
      push: literal-paragraph-body

  literal-paragraph-body:
    - meta_scope: meta.paragraph.asciidoc markup.raw.block.asciidoc
    - include: paragraph-body-pops
    - include: comments-inline
    - include: inlines

  paragraph-body-pops:
    - match: ^$
      pop: 1
    - include: pop-block-anyway
    - match: ^(?=.+{{description_list_marker}}\s|$)
      pop: 1

###[ DISCRETE HEADINGS ]#######################################################

  # Nothing to do here

###[ BREAKS ]##################################################################

  # https://docs.asciidoctor.org/asciidoc/latest/blocks/breaks/
  breaks:
    - include: thematic-breaks
    - include: page-breaks

  thematic-breaks:
    - match: ^(?:'''|\*\*\*|---|\* \* \*|- - -)$
      scope: punctuation.section.block.thematic.asciidoc

  page-breaks:
    - match: ^<<<$
      scope: keyword.control.flow.break.asciidoc

###[ TEXT FORMATTING AND PUNCTUATION ]#########################################

  text-formatting:
    - match: '`"|"`'
      scope: constant.character.escape.asciidoc
    - match: "`'|'`"
      scope: constant.character.escape.asciidoc
    - include: text-formatting-unconstrained
    - include: text-formatting-constrained

  text-formatting-constrained:
    - include: text-bold
    - include: text-italic
    - include: text-monospace
    - include: text-highlight
    - include: text-subscript
    - include: text-superscript

  text-bold:
    - match: \B\*(?=\S)
      scope: punctuation.definition.bold.begin.asciidoc
      push: text-bold-body

  text-bold-body:
    - meta_scope: markup.bold.asciidoc
    - match: \*\B
      scope: punctuation.definition.bold.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal
    - include: inlines

  text-italic:
    - match: \b_(?=\S)
      scope: punctuation.definition.italic.begin.asciidoc
      push: text-italic-body

  text-italic-body:
    - meta_scope: markup.italic.asciidoc
    - match: _\b
      scope: punctuation.definition.italic.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal
    - include: inlines

  text-monospace:
    - match: \B`(?=\S)
      scope: punctuation.definition.raw.begin.asciidoc
      captures:
        1: keyword.control.passthrough.asciidoc
      push: text-monospace-body

  text-monospace-body:
    - meta_scope: markup.raw.inline.asciidoc
    - match: '`\B'
      scope: punctuation.definition.raw.end.asciidoc
      captures:
        1: keyword.control.passthrough.asciidoc
      pop: 1
    - include: pop-blank-line-illegal
    - include: inlines

  text-highlight:
    - match: \B#(?=\S.*#)
      scope: punctuation.definition.highlight.begin.asciidoc
      push: text-highlight-body

  text-highlight-body:
    - meta_scope: markup.bold.highlight.asciidoc
    - match: '#\B'
      scope: punctuation.definition.highlight.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal
    - include: inlines

  text-subscript:
    - match: \B~(?=\S)
      scope: punctuation.definition.subscript.begin.asciidoc
      push: text-subscript-body

  text-subscript-body:
    - meta_scope: markup.italic.subscript.asciidoc
    - match: '~'
      scope: punctuation.definition.subscript.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal
    - include: inlines

  text-superscript:
    - match: \B\^(?=\S)
      scope: punctuation.definition.superscript.begin.asciidoc
      push: text-superscript-body

  text-superscript-body:
    - meta_scope: markup.italic.superscript.asciidoc
    - match: \^
      scope: punctuation.definition.superscript.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal
    - include: inlines

  text-formatting-unconstrained:
    - include: text-bold-unconstrained
    - include: text-italic-unconstrained
    - include: text-monospace-unconstrained
    - include: text-highlight-unconstrained
    - include: text-subscript-unconstrained
    - include: text-superscript-unconstrained

  text-bold-unconstrained:
    - match: \*\*
      scope: punctuation.definition.bold.begin.asciidoc
      push: text-bold-unconstrained-body

  text-bold-unconstrained-body:
    - meta_scope: markup.bold.asciidoc
    - match: \*\*
      scope: punctuation.definition.bold.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal
    - include: inlines

  text-italic-unconstrained:
    - match: __
      scope: punctuation.definition.italic.begin.asciidoc
      push: text-italic-unconstrained-body

  text-italic-unconstrained-body:
    - meta_scope: markup.italic.asciidoc
    - match: __
      scope: punctuation.definition.italic.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal
    - include: inlines

  text-monospace-unconstrained:
    - match: '``'
      scope: punctuation.definition.raw.begin.asciidoc
      push: text-monospace-unconstrained-body

  text-monospace-unconstrained-body:
    - meta_scope: markup.raw.inline.asciidoc
    - match: '``'
      scope: punctuation.definition.raw.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal

  text-highlight-unconstrained:
    - match: '##'
      scope: punctuation.definition.highlight.begin.asciidoc
      push: text-highlight-unconstrained-body

  text-highlight-unconstrained-body:
    - meta_scope: markup.bold.highlight.asciidoc
    - match: '##'
      scope: punctuation.definition.highlight.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal
    - include: inlines

  text-subscript-unconstrained:
    - match: ~~
      scope: punctuation.definition.subscript.begin.asciidoc
      push: text-subscript-unconstrained-body

  text-subscript-unconstrained-body:
    - meta_scope: markup.italic.subscript.asciidoc
    - match: ~~
      scope: punctuation.definition.subscript.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal
    - include: inlines

  text-superscript-unconstrained:
    - match: \^\^
      scope: punctuation.definition.superscript.begin.asciidoc
      push: text-superscript-unconstrained-body

  text-superscript-unconstrained-body:
    - meta_scope: markup.italic.superscript.asciidoc
    - match: \^\^
      scope: punctuation.definition.superscript.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal
    - include: inlines

###[ LISTS ]###################################################################

  lists:
    # TODO: list titles
    - match: '^\s*([.*-]+) +'
      captures:
        1: punctuation.definition.list_item.asciidoc
      push: list-item
    - match: ([ \t]*)(\d{1,9}(\.))(\s)
      captures:
        1: markup.list.numbered.markdown
        2: markup.list.numbered.bullet.markdown
        3: punctuation.definition.list_item.markdown
        4: markup.list.numbered.markdown
      push: list-item

  list-item:
    - meta_scope: meta.paragraph.list.asciidoc
    - match: ^(?=\s*(?:[.*-]|\d+\.))
      pop: 1
    # If there's a blank line, we might be in indented blocks
    - match: ^$
      set: maybe-indented-list-value
    - include: pop-block-anyway
    - match: \G(\[)([*xX ])(\])
      captures:
        1: markup.checkbox.begin.asciidoc punctuation.definition.checkbox.begin.asciidoc
        2: markup.checkbox.mark.asciidoc
        3: markup.checkbox.end.asciidoc punctuation.definition.checkbox.end.asciidoc
    - include: comments-inline
    - include: inlines

###[ DESCRIPTION LISTS ]#######################################################

  description-lists:
    - match: ^(?=.+{{description_list_marker}}\s)
      push: description-list-term

  description-list-term:
    - meta_content_scope: meta.mapping.key.asciidoc
    - match: '{{description_list_marker}}(?=\s|$)'
      scope: punctuation.separator.key-value.asciidoc
      set: description-list-value
    - include: inlines

  description-list-value:
    - meta_content_scope: meta.mapping.value.asciidoc
    # If there's a blank line, we might be in indented blocks
    - match: ^$
      set: maybe-indented-list-value
    - include: pop-block-anyway
    - include: comments-inline
    - include: inlines
    - include: lists

  maybe-indented-list-value:
    - meta_content_scope: meta.mapping.value.asciidoc
    - match: ^(?=\S)
      pop: 1
    - include: indented-blocks
    - include: inlines

###[ LINKS ]###################################################################

  links:
    - include: autolinks
    - include: link-macros

  link-macros:
    - match: \b(link)(:)
      captures:
        1: keyword.control.import.asciidoc
        2: punctuation.separator.asciidoc
      push: link-macro-arguments

  link-macro-arguments:
    - meta_content_scope: markup.underline.link.asciidoc
    - match: \[
      scope: punctuation.section.group.parameters.begin.asciidoc
      set: attribute-list-body
    - include: passthrough-inlines
    - include: link-special-characters
    - include: document-attributes

  autolinks:
    - match: '{{autolink_scheme}}'
      push: link-body

  link-body:
    - meta_scope: markup.underline.link.asciidoc
    - match: (?=\.?{{link_pop}})
      pop: 1
    - include: link-special-characters

  link-special-characters:
    - match: '[:?#@]'
      scope: punctuation.separator.sequence.asciidoc

###[ CROSS-REFERENCES ]########################################################

  cross-references:
    # Links
    - match: <<
      scope: punctuation.definition.reference.begin.asciidoc
      push: cross-reference-natural-body
    - match: \b(xref)(:)
      captures:
        1: keyword.control.import.asciidoc
        2: punctuation.separator.asciidoc
      push: link-macro-arguments
    # Anchors
    - match: \[\[
      scope: punctuation.definition.reference.begin.asciidoc
      push: anchor-natural-body
    - match: \b(anchor)(:)
      captures:
        1: keyword.control.import.asciidoc
        2: punctuation.separator.asciidoc
      push: anchor-macro-arguments

  cross-reference-natural-body:
    - meta_content_scope: meta.link.reference.metadata.asciidoc markup.underline.link.asciidoc
    - match: '>>'
      scope: punctuation.definition.reference.end.asciidoc
      pop: 1
    - match: ','
      scope: punctuation.separator.sequence.asciidoc
      set: cross-reference-natural-attributes

  cross-reference-natural-attributes:
    - meta_content_scope: meta.link.reference.metadata.asciidoc
    - match: '>>'
      scope: punctuation.definition.reference.end.asciidoc
      pop: 1
    - include: attribute-list-contents

  anchor-natural-body:
    - meta_content_scope: entity.name.reference.link.asciidoc
    - match: ']]'
      scope: punctuation.definition.reference.end.asciidoc
      pop: 1
    - match: ','
      scope: punctuation.separator.sequence.asciidoc
      set: anchor-natural-attributes

  anchor-natural-attributes:
    - meta_content_scope: meta.link.reference.metadata.asciidoc
    - match: ']]'
      scope: punctuation.definition.reference.end.asciidoc
      pop: 1
    - include: attribute-list-contents

  anchor-macro-arguments:
    - meta_content_scope: entity.name.reference.link.asciidoc
    - match: \[
      scope: punctuation.section.group.parameters.begin.asciidoc
      set: attribute-list-body
    - include: passthrough-inlines
    - include: link-special-characters
    - include: document-attributes

###[ FOOTNOTES ]###############################################################

  footnotes:
    - match: \b(footnote)(:)
      captures:
        1: keyword.control.flow.asciidoc
        2: punctuation.separator.asciidoc
      push:
        - footnote-content
        - footnote-type

  footnote-type:
    - meta_content_scope: storage.modifier.asciidoc
    - match: (?=\[)
      pop: 1
    - match: (?=\s)
      pop: 1

  footnote-content:
    - match: \[
      scope: punctuation.definition.string.begin.asciidoc
      push: footnote-content-body
    - include: else-pop

  footnote-content-body:
    - meta_scope: string.unquoted.asciidoc
    - match: \]
      scope: punctuation.definition.string.end.asciidoc
      pop: 1
    - include: inlines

###[ IMAGES ]##################################################################

  block-images:
    - match: \b(image)(::)
      captures:
        1: keyword.control.import.asciidoc
        2: punctuation.separator.asciidoc
      push: include-arguments

  inline-images:
    - match: \b(image)(:)
      captures:
        1: keyword.control.import.asciidoc
        2: punctuation.separator.asciidoc
      push: include-arguments

###[ AUDIO AND VIDEO ]#########################################################

  audios-and-videos:
    - match: \b(audio|video)(::)
      captures:
        1: keyword.control.import.asciidoc
        2: punctuation.separator.asciidoc
      push: include-arguments

###[ ICONS ]###################################################################

  # Nothing to do here

###[ KEYBOARD MACRO ]##########################################################

  keyboard-macro:
    - match: \b(kbd)(:)(\[)
      captures:
        1: support.function.asciidoc
        2: punctuation.separator.asciidoc
        3: punctuation.definition.string.begin.asciidoc
      push: keyboard-macro-body

  keyboard-macro-body:
    - meta_content_scope: string.unquoted.asciidoc
    - include: eol-pop
    - match: \+
      scope: punctuation.separator.sequence.asciidoc
    - match: \]
      scope: punctuation.definition.string.end.asciidoc
      pop: 1

###[ BUTTON AND MENU UI MACROS ]###############################################

  button-menu-macro:
    - match: \b(btn|menu)(:)
      captures:
        1: keyword.control.import.asciidoc
        2: punctuation.separator.asciidoc
      push: button-menu-arguments

  button-menu-arguments:
    - meta_content_scope: entity.name.class.asciidoc
    - match: \[
      scope: punctuation.definition.string.begin.asciidoc
      set: button-menu-body
    - include: eol-pop

  button-menu-body:
    - match: \]
      scope: punctuation.definition.string.end.asciidoc
      pop: 1
    - match: '>'
      scope: punctuation.separator.sequence.asciidoc
    - match: '[^\]>]'
      scope: entity.name.class.asciidoc

###[ ADMONITIONS ]#############################################################

  admonitions:
    - match: ^({{admonition}})(:)
      captures:
        1: support.type.admonition.asciidoc
        2: punctuation.separator.key-value.asciidoc
      push: paragraph-body

###[ SIDEBARS ]################################################################

  sidebars:
    - match: ^\*{4}$
      scope: punctuation.section.sidebar.begin.asciidoc
      push: sidebar-body

  sidebar-body:
    - meta_scope: meta.block.sidebar.asciidoc
    - match: ^\*{4}$
      scope: punctuation.section.sidebar.end.asciidoc
      pop: 1
    - include: blocks

###[ EXAMPLE BLOCKS ]##########################################################

  example-blocks:
    - match: ^={4}$
      scope: punctuation.section.example.begin.asciidoc
      push: example-block-body

  example-block-body:
    - meta_scope: meta.block.example.asciidoc
    - match: ^={4}$
      scope: punctuation.section.example.end.asciidoc
      pop: 1
    - include: blocks

###[ BLOCKQUOTES ]#############################################################

  # Blockquotes are the same as Verses
  blockquotes: []

###[ VERSES ]##################################################################

  verses:
    - match: ^_{4}$
      scope: punctuation.section.verse.begin.asciidoc
      push: verse-body

  verse-body:
    - meta_scope: meta.block.verse.asciidoc
    - match: ^_{4}$
      scope: punctuation.section.verse.end.asciidoc
      pop: 1

###[ VERBATIM AND SOURCE BLOCKS ]##############################################

  # TODO: Maybe detect and inject language syntax?

  verbatims-and-source-blocks:
    - include: verbatims
    - include: literal-blocks

  verbatims:
    - match: ^(-{4,})\s*$
      captures:
        1: punctuation.definition.raw.code-fence.begin.asciidoc
      push: verbatim-body

  verbatim-body:
    - meta_content_scope: markup.raw.code-fence.asciidoc
    - match: ^\1$
      scope: punctuation.definition.raw.code-fence.end.asciidoc
      pop: 1
    - include: verbatim-line-annotations
    - include: includes

  verbatim-line-annotations:
    - match: (<(?:!--)?)\d+((?:--)?>)
      scope: comment.block.asciidoc
      captures:
        1: punctuation.definition.comment.begin.asciidoc
        2: punctuation.definition.comment.end.asciidoc

  literal-blocks:
    - include: delimited-literal-blocks

  delimited-literal-blocks:
    - match: ^(\.{4})\s*$
      captures:
        1: punctuation.definition.raw.literal.begin.asciidoc
      push: delimited-literal-blocks-body

  delimited-literal-blocks-body:
    - meta_content_scope: markup.raw.code-fence.asciidoc
    - match: ^\.{4}$
      scope: punctuation.definition.raw.code-fence.end.asciidoc
      pop: 1

###[ TABLES ]##################################################################

  tables:
    - match: ^\|===$
      scope: punctuation.section.block.table.begin.asciidoc
      push: table-body
    - match: ^,===$
      scope: punctuation.section.block.table.begin.asciidoc
      push: table-body-csv
    - match: ^:===$
      scope: punctuation.section.block.table.begin.asciidoc
      push: table-body-dsv

  table-body:
    - meta_scope: meta.table.asciidoc
    - match: ^\|===$
      scope: punctuation.section.block.table.end.asciidoc
      pop: 1
    # TODO: Cell formatting
    - match: \|
      scope: punctuation.separator.table-cell.asciidoc
    - include: blocks
    - include: inlines

  table-body-csv:
    - meta_scope: meta.table.asciidoc
    - match: ^,===$
      scope: punctuation.section.block.table.end.asciidoc
      pop: 1
    - match: ','
      scope: punctuation.separator.table-cell.asciidoc
    - include: comments-inline
    - include: includes

  table-body-dsv:
    - meta_scope: meta.table.asciidoc
    - match: ^:===$
      scope: punctuation.section.block.table.end.asciidoc
      pop: 1
    - match: ':'
      scope: punctuation.separator.table-cell.asciidoc
    - include: comments-inline
    - include: includes

###[ EQUATIONS AND FORMULAE ]##################################################

###[ OPEN BLOCKS ]#############################################################

  open-blocks:
    - match: ^--$
      scope: punctuation.section.block.begin.asciidoc
      push: open-block-body

  open-block-body:
    - meta_scope: meta.block.open.asciidoc
    - match: ^--$
      scope: punctuation.section.block.end.asciidoc
      pop: 1
    # Assume for now that it's still AsciiDoc
    - include: indented-blocks

###[ COLLAPSIBLE BLOCKS ]######################################################

  # Collapsible blocks use the same format as example blocks

###[ COMMENTS ]################################################################

  # https://docs.asciidoctor.org/asciidoc/latest/comments/
  comments:
    - include: comments-block
    - include: comments-inline

  comments-inline:
    - match: ^\s*(//)
      captures:
        1: punctuation.definition.comment.begin.asciidoc
      push: comment-inline-body

  comment-inline-body:
    - meta_scope: comment.line.double-slash.asciidoc
    - include: eol-pop

  comments-block:
    - include: comments-block-delimited
    # TODO: [comment] block and paragraph

  comments-block-delimited:
    - match: ^\s*(////)
      captures:
        1: punctuation.definition.comment.begin.asciidoc
      push: comment-block-delimited-body

  comment-block-delimited-body:
    - meta_scope: comment.block.quad-slash.asciidoc
    - match: ^\s*(////)
      captures:
        1: punctuation.definition.comment.end.asciidoc
      pop: 1

###[ AUTOMATIC TABLE OF CONTENTS ]#############################################

  # Nothing to do here.

###[ DOCINFO FILES ]###########################################################

  # Nothing to do here.

###[ INCLUDES ]################################################################

  includes:
    - match: \b(include)(::)
      captures:
        1: keyword.control.import.asciidoc
        2: punctuation.separator.asciidoc
      push: include-arguments

  include-arguments:
    - meta_content_scope: string.unquoted.asciidoc
    - match: \[
      scope: punctuation.section.group.parameters.begin.asciidoc
      set: attribute-list-body
    - match: /
      scope: punctuation.separator.sequence.asciidoc
    - include: document-attributes

###[ CONDITIONALS ]############################################################

  conditionals:
    - match: \b(if(?:n?def|eval))(::)
      captures:
        1: keyword.control.conditional.if.asciidoc
        2: punctuation.separator.asciidoc
      push:
        - if-block
        - if-arguments

  if-arguments:
    - meta_content_scope: variable.other.readwrite.asciidoc
    - match: \[\]
      scope: punctuation.section.group.asciidoc
      pop: 1
    # TODO: Support the one-line version
    - include: eol-pop

  if-block:
    - meta_scope: meta.block.conditional.asciidoc
    - match: \b(endif)(?:(::)(\S*)(\[\]))?
      captures:
        1: keyword.control.conditional.end.asciidoc
        2: punctuation.separator.asciidoc
        3: variable.other.readwrite.asciidoc
        4: punctuation.section.group.asciidoc
      pop: 1
    - include: blocks

###[ SUBSTITUTIONS ]###########################################################

  substitutions:
    - match: \(C\)|\(R\)|\(TM\)|--(?!-)|\.\.\.(?!\.)|->|<-|=>|<=
      scope: constant.character.asciidoc
    # TODO: Check HTML entities

###[ PASSTHROUGHS ]############################################################

  passthrough-blocks:
    - match: ^(\+{4})\s*$
      captures:
        1: keyword.control.passthrough.begin.asciidoc
      push: passthrough-block-body

  passthrough-block-body:
    - meta_content_scope: markup.raw.passthrough.asciidoc
    - match: ^\+{4}$
      scope: keyword.control.passthrough.end.asciidoc
      pop: 1

  passthrough-inlines:
    - match: (\+{2,3})(?=\S)
      scope: keyword.control.passthrough.begin.asciidoc
      push: passthrough-inline-body-unconstrained
    - match: \B\+(?=\S.*\+)
      scope: keyword.control.passthrough.begin.asciidoc
      push: passthrough-inline-body
    - match: \b(pass)(:)
      captures:
        1: keyword.control.passthrough.asciidoc
        2: punctuation.separator.asciidoc
      push: pass-inline-content

  passthrough-inline-body:
    - meta_scope: markup.raw.inline.asciidoc
    - match: \+\B
      scope: keyword.control.passthrough.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal

  passthrough-inline-body-unconstrained:
    - meta_scope: markup.raw.inline.asciidoc
    - match: \1
      scope: keyword.control.passthrough.end.asciidoc
      pop: 1
    - include: pop-blank-line-illegal

  pass-inline-content:
    - match: \[
      scope: punctuation.definition.string.begin.asciidoc
      push: pass-inline-content-body
    - include: else-pop

  pass-inline-content-body:
    - meta_scope: markup.raw.inline.asciidoc
    - match: \]
      scope: punctuation.definition.string.end.asciidoc
      pop: 1

###[ PROTOTYPE ]###############################################################

  eol-pop:
    - match: $\n?
      pop: 1

  else-pop:
    - match: (?=\S)
      pop: 1

  pop-blank-line:
    - match: ^$\n?
      pop: 1

  pop-blank-line-illegal:
    - match: ^$\n?
      scope: invalid.illegal.new-block.asciidoc
      pop: 1

  pop-block-anyway:
    - match: ^(?=.+{{description_list_marker}}\s|$)
      pop: 1
    - match: ^(?=:|[=|,]=|--|\*{4}|\+$|include|endif|if(?:n?def|eval))
      pop: 1

###[ OLD ]#####################################################################

  # old-main:
  #   - include: heading_inline
  #   - include: heading-block
  #   - include: heading-blockattr
  #   - match: \$\$(?!\$)
  #     push:
  #       - meta_scope: comment.block.passthrough.macro.doubledollar.asciidoc
  #       - match: \$\$(?!\$)
  #         pop: true
  #   - match: \+\+\+(?!\+)
  #     push:
  #       - meta_scope: comment.block.passthrough.macro.tripeplus.asciidoc
  #       - match: \+\+\+(?!\+)
  #         pop: true
  #   - match: (//).*$\n?
  #     scope: comment.line.double-slash.asciidoc
  #   - match: |-
  #       (?x)^
  #       (?= ([/+-.*_=]{4,})\s*$
  #       | ([ \t]{1,})
  #       | [=]{1,6}\s*+
  #       | [ ]{,3}(?<marker>[-*_])([ ]{,2}\k<marker>){2,}[ \t]*+$
  #       )
  #     push:
  #       - meta_scope: meta.block-level.asciidoc
  #       - match: |-
  #           (?x)^
  #           (?! \1
  #           | ([ \t]{1,})
  #           | [=]{1,6}\s*+
  #           | [ ]{,3}(?<marker>[-*_])([ ]{,2}\k<marker>){2,}[ \t]*+$
  #           )
  #         pop: true
  #       - include: block_quote
  #       - include: block_raw
  #       - include: heading_inline
  #       - include: heading-block
  #       - include: separator
  #   - match: '^[ ]{0,3}([*+-])(?=\s)'
  #     captures:
  #       1: punctuation.definition.list_item.asciidoc
  #     push:
  #       - meta_scope: markup.list.unnumbered.asciidoc
  #       - match: ^(?=\S)
  #         captures:
  #           1: punctuation.definition.list_item.asciidoc
  #         pop: true
  #       - include: list-paragraph
  #   - match: '^[ ]{0,3}[0-9]+(\.)(?=\s)'
  #     captures:
  #       1: punctuation.definition.list_item.asciidoc
  #     push:
  #       - meta_scope: markup.list.numbered.asciidoc
  #       - match: ^(?=\S)
  #         captures:
  #           1: punctuation.definition.list_item.asciidoc
  #         pop: true
  #       - include: list-paragraph
  #   - match: '^([/+-.*_=]){4,}\s*$'
  #     push:
  #       - meta_scope: comment.block.asciidoc
  #       - match: '^\1{4,}\s*$'
  #         pop: true
  #   # asciidoc formatting is disabled inside certain blocks.
  #   - match: '^([/+.]){4,}\s*$'
  #     push:
  #       - meta_scope: meta.disable-asciidoc
  #       - match: '^[/+.]{4,}\s*$'
  #         pop: true
  #   - match: '^(?=\S)(?![=-]{3,}(?=$))(?!\.\S+)'
  #     push:
  #       - meta_scope: meta.paragraph.asciidoc
  #       - match: '^(?:\s*$|(?=[ ]{,3}>.))|(?=[ \t]*\n)(?<=^===|^====|=====|^---|^----|-----)[ \t]*\n'
  #         pop: true
  #       - include: inline
  #       - include: scope:text.html.basic
  #       - match: '^(={3,})(?=[ \t]*$)'
  #         scope: markup.heading.0.asciidoc
  #         captures:
  #           1: punctuation.definition.heading.asciidoc
  #       - match: '^(-{3,})(?=[ \t]*$)'
  #         scope: markup.heading.1.asciidoc
  #         captures:
  #           1: punctuation.definition.heading.asciidoc
  #       - match: '^(~{3,})(?=[ \t]*$)'
  #         scope: markup.heading.2.asciidoc
  #         captures:
  #           1: punctuation.definition.heading.asciidoc
  #       - match: '^(\^{3,})(?=[ \t]*$)'
  #         scope: markup.heading.3.asciidoc
  #         captures:
  #           1: punctuation.definition.heading.asciidoc
  #       - match: '^(\+{3,})(?=[ \t]*$)'
  #         scope: markup.heading.4.asciidoc
  #         captures:
  #           1: punctuation.definition.heading.asciidoc

  # attribute-entry:
  #   - match: '^:[-_. A-Za-z0-9]+:\s*(.*)\s*$'
  #     scope: variable.other

  # attribute-reference:
  #   - match: '{[-_. A-Za-z0-9]+}'
  #     scope: variable.other

  # attribute-reference-predefined:
  #   - match: '{(?i:amp|asciidoc-dir|asciidoc-file|asciidoc-version|author|authored|authorinitials|backend-docbook|backend-xhtml11|backend-html4|docbook-article|xhtml11-article|html4-article|docbook-book|xhtml11-book|html4-book|docbook-manpage|xhtml11-manpage|html4-manpage|backend|backslash|basebackend|brvbar|date|docdate|doctime|docname|docfile|docdir|doctitle|doctype-article|doctype-book|doctype-manpage|doctype|email|empty|encoding|filetype|firstname|gt|id|indir|infile|lastname|level|listindex|localdate|localtime|lt|manname|manpurpose|mantitle|manvolnum|middlename|nbsp|outdir|outfile|reftext|revision|sectnum|showcomments|title|two_colons|two_semicolons|user-dir|verbose)}'
  #     scope: support.variable

  # block_quote:
  #   - match: '^([/+-.*_=]){4,}\s*$'
  #     push:
  #       - meta_scope: comment.block.asciidoc
  #       - match: '^\1{4,}\s*$'
  #         pop: true

  # block_raw:
  #   - match: '\G([ ]{4}|\t).*$\n?'
  #     scope: markup.raw.block.asciidoc

  # bracket:
  #   # asciidoc will convert this for us. We match it so that the HTML grammar
  #   #   will not mark it up as invalid.
  #   - match: '<(?![a-z/?\$!])'
  #     scope: meta.other.valid-bracket.asciidoc

  # character-replacements:
  #   - match: \(C\)|\(R\)|\(TM\)|--(?!-)|\.\.\.(?!\.)|->|<-|=>|<=
  #     scope: constant.character.asciidoc

  # escape:
  #   - match: '\\[-`*_#+.!(){}\[\]\\>:]'
  #     scope: constant.character.escape.asciidoc

  # heading:
  #   - match: '(?m)^(\S+)$([=-~^+])+\s*$'
  #     scope: markup.heading.asciidoc
  #     captures:
  #       1: punctuation.definition.heading.asciidoc

  # heading-block:
  #   - match: ^\.(\w.*)$
  #     scope: markup.heading.asciidoc
  #     captures:
  #       1: punctuation.definition.heading.asciidoc

  # heading-blockattr:
  #   - match: '^\[\[?(\w.*)\]$'
  #     scope: markup.heading.asciidoc
  #     captures:
  #       1: punctuation.definition.heading.asciidoc

  # heading_inline:
  #   - match: '\G(={1,6})(?!=)\s*(?=\S)'
  #     captures:
  #       1: punctuation.definition.heading.asciidoc
  #     push:
  #       - meta_scope: markup.heading.asciidoc
  #       - meta_content_scope: entity.name.section.asciidoc
  #       - match: \s*(=*)$\n?
  #         captures:
  #           1: punctuation.definition.heading.asciidoc
  #         pop: true
  #       - include: inline

  # inline:
  #   - include: line-break
  #   - include: line-page-break
  #   - include: line-ruler
  #   - include: escape
  #   - include: passthrough-macro-trippleplus-inline
  #   - include: passthrough-macro-doubledollar-inline
  #   - include: character-replacements
  #   - include: bracket
  #   - include: raw
  #   - include: text-quote-single
  #   - include: text-quote-double
  #   - include: text-quote-other
  #   - include: text-bold-unconstrained
  #   - include: text-italic-unconstrained
  #   - include: text-monospace-unconstrained
  #   - include: text-unquoted-unconstrained
  #   - include: text-bold
  #   - include: text-italic
  #   - include: text-monospace
  #   - include: text-unquoted
  #   - include: attribute-entry
  #   - include: attribute-reference-predefined
  #   - include: attribute-reference

  # line-break:
  #   - match: (?<=\S)\s+\+$
  #     scope: constant.character.escape.asciidoc

  # line-page-break:
  #   - match: '^<{3,}$'
  #     scope: constant.character.escape.asciidoc

  # line-ruler:
  #   - match: '^''{3,}$'
  #     scope: constant.character.escape.asciidoc

  # list-paragraph:
  #   - match: \G\s+(?=\S)
  #     push:
  #       - meta_scope: meta.paragraph.list.asciidoc
  #       - match: ^\s*$
  #         pop: true
  #       - include: inline

  # passthrough-macro-doubledollar-inline:
  #   - match: '(?:\[.*\])?\$\$(?!\$).+\$\$(?!\$)'
  #     scope: comment.block.passthrough.asciidoc

  # passthrough-macro-trippleplus-inline:
  #   - match: '(?:\[.*\])?\+\+\+(?!\+).+\+\+\+(?!\+)'
  #     scope: comment.block.passthrough.asciidoc

  # raw:
  #   - match: '(`+)(?:[^`]|(?!(?<!`)\1(?!`))`)*+(\1)'
  #     scope: markup.raw.inline.asciidoc
  #     captures:
  #       1: punctuation.definition.raw.asciidoc
  #       2: punctuation.definition.raw.asciidoc

  # separator:
  #   - match: '\G[ ]{,3}([-*_])([ ]{,2}\1){2,}[ \t]*$\n?'
  #     scope: meta.separator.asciidoc

  # text-bold:
  #   - match: (?<!\w)(\*)(?=\S)
  #     captures:
  #       1: punctuation.definition.bold.asciidoc
  #     push:
  #       - meta_scope: markup.bold.asciidoc
  #       - match: (?<=\S)(\1)(?!\w)
  #         captures:
  #           1: punctuation.definition.bold.asciidoc
  #         pop: true

  # text-bold-unconstrained:
  #   - match: (\*\*)(?=\S)
  #     captures:
  #       1: punctuation.definition.bold.asciidoc
  #     push:
  #       - meta_scope: markup.bold.asciidoc
  #       - match: (?<=\S)(\1)
  #         captures:
  #           1: punctuation.definition.bold.asciidoc
  #         pop: true

  # text-italic:
  #   - match: (?<!\w)('|_)(?=\S)
  #     captures:
  #       1: punctuation.definition.italic.asciidoc
  #     push:
  #       - meta_scope: markup.italic.asciidoc
  #       - match: (?<=\S)(\1)((?!\1)|(?=\1\1))(?!\w)
  #         captures:
  #           1: punctuation.definition.italic.asciidoc
  #         pop: true

  # text-italic-unconstrained:
  #   - match: (__)(?=\S)
  #     captures:
  #       1: punctuation.definition.italic.asciidoc
  #     push:
  #       - meta_scope: markup.italic.asciidoc
  #       - match: (?<=\S)(\1)
  #         captures:
  #           1: punctuation.definition.italic.asciidoc
  #         pop: true

  # text-monospace:
  #   - match: '(?<!\w)([\+`])[^\+]*(\1)(?!\w)'
  #     scope: string.interpolated.asciidoc

  # text-monospace-unconstrained:
  #   - match: (\+\+).*(\1)
  #     scope: string.interpolated.asciidoc

  # text-quote-double:
  #   - match: '(?<!\w)(?:\[.*\])?``(?!`).*''''(?!'')(?!\w)'
  #     scope: string.quoted.double.asciidoc

  # text-quote-other:
  #   - match: '(?<!\w)(?:\[.*\])?([~^]).*(\1)(?!\w)'
  #     scope: string.quoted.single.asciidoc

  # text-quote-single:
  #   # TODO: Sub- and Superscript are really unconstrained
  #   - match: '(?<!\w)(?:\[.*\])?`(?!`).*''(?!'')(?!\w)'
  #     scope: string.quoted.single.asciidoc

  # text-unquoted:
  #   - match: (?<!\w)(#).*(\1)(?!\w)
  #     scope: string.unquoted.asciidoc

  # text-unquoted-unconstrained:
  #   - match: (##).*(\1)
  #     scope: string.unquoted.asciidoc

variables:
  identifier: (?:[a-z](?:[a-z0-9-]*[a-z0-9])?)
  admonition: \b(?:NOTE|IMPORTANT|TIP|CAUTION|WARNING)\b
  block_type: \b(?:source|quote|discrete|qanda)\b
  description_list_marker: (?:;;|:{2,4})
  autolink_scheme: \b(?:https?|ftp|irc|mailto)\b
  link_pop: (?:$|[\s\[\]()'"])
  doctype: (?:article|book|manpage|inline)
